<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Validator Node ‚Äî Soulprint Docs</title>
<meta name="description" content="Run a Soulprint validator node ‚Äî HTTP API on port 4888, P2P mesh on port 6888, full configuration reference.">
<link rel="stylesheet" href="shared.css">
</head>
<body>
<div class="topbar">
  <a href="/" class="topbar-logo">üåÄ Soulprint</a>
  <div class="topbar-links"><a href="https://github.com/manuelariasfz/soulprint">GitHub</a><a href="/">Home</a></div>
</div>
<div class="docs-layout">
  <aside class="sidebar">
    <div class="sidebar-logo">
      <svg viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
        <defs><linearGradient id="g" x1="0%" y1="0%" x2="100%" y2="100%">
          <stop offset="0%" stop-color="#7c6cf5"/><stop offset="100%" stop-color="#a78bfa"/>
        </linearGradient></defs>
        <circle cx="32" cy="26" r="18" fill="url(#g)"/>
        <rect x="14" y="26" width="36" height="20" fill="url(#g)"/>
        <circle cx="19" cy="48" r="5.5" fill="url(#g)"/>
        <circle cx="32" cy="49" r="5.5" fill="url(#g)"/>
        <circle cx="45" cy="48" r="5.5" fill="url(#g)"/>
        <ellipse cx="25" cy="25" rx="4.5" ry="3" fill="#0a0a0f"/>
        <ellipse cx="25" cy="25" rx="2.5" ry="1.8" fill="#ffffff"/>
        <ellipse cx="39" cy="25" rx="4.5" ry="3" fill="#0a0a0f"/>
        <ellipse cx="39" cy="25" rx="2.5" ry="1.8" fill="#ffffff"/>
      </svg>
      <span class="sidebar-logo-text">Soulprint Docs</span>
    </div>
    <nav>
      <div class="sidebar-section">Getting Started</div>
      <a href="index.html">Overview</a><a href="quickstart.html">Quick Start</a>
      <div class="sidebar-section">Core Concepts</div>
      <a href="verify.html">Identity Verification</a><a href="trust-score.html">Trust Score (0‚Äì100)</a>
      <div class="sidebar-section">Integrations</div>
      <a href="mcp.html">MCP Servers</a><a href="openclaw.html">OpenClaw Bots</a>
      <div class="sidebar-section">Infrastructure</div>
      <a href="validator.html" class="active">Validator Node</a><a href="api.html">REST API Reference</a>
      <div class="sidebar-section">Ecosystem</div>
      <a href="countries.html">Country Support</a>
    </nav>
  </aside>
  <main class="content">
    <div class="doc-hero">
      <h1>üåê Validator Node</h1>
      <p class="subtitle">Run a node in the Soulprint P2P network ‚Äî verify proofs, issue reputation attestations, earn validator status.</p>
    </div>

    <h2>Quick Start</h2>
    <pre><code><span class="comment"># Start the node (HTTP 4888 + P2P 6888)</span>
npx soulprint node

<span class="comment"># Or install globally first:</span>
npm install -g soulprint
soulprint node</code></pre>
    <p>Example startup output:</p>
    <pre><code>üåÄ Soulprint Validator Node v0.2.2
‚úÖ HTTP API listening on http://0.0.0.0:4888
‚úÖ P2P node started
   Peer ID:    12D3KooW[...generated peer ID...]
   Multiaddr:  /ip4/0.0.0.0/tcp/6888/p2p/12D3KooW[...]
‚úÖ mDNS discovery active (local network)
‚è≥ Waiting for bootstrap peers...
   (No bootstrap peers configured ‚Äî running standalone)</code></pre>

    <h2>Credential Validators <span style="font-size:0.7em;background:#7c6cf5;color:#fff;padding:2px 8px;border-radius:10px;margin-left:8px">v0.3.0</span></h2>
    <p>Every validator node ships with three open-source credential verifiers ‚Äî no API keys required.</p>

    <h3>üìß Email OTP</h3>
    <pre><code>POST /credentials/email/start   { "did": "...", "email": "user@example.com" }
<span class="comment">// ‚Üí OTP sent via nodemailer (dev: Ethereal preview, prod: SMTP config)</span>
POST /credentials/email/verify  { "sessionId": "...", "otp": "123456" }
<span class="comment">// ‚Üí { credential: "EmailVerified", attestation }</span></code></pre>
    <p>Config: <code>SMTP_HOST</code>, <code>SMTP_PORT</code>, <code>SMTP_USER</code>, <code>SMTP_PASS</code> (all optional for dev)</p>

    <h3>üì± Phone TOTP (RFC 6238 ‚Äî no SMS)</h3>
    <pre><code>POST /credentials/phone/start   { "did": "...", "phone": "+573001234567" }
<span class="comment">// ‚Üí { sessionId, totpUri } ‚Äî scan QR with Google Authenticator / Authy / Aegis</span>
POST /credentials/phone/verify  { "sessionId": "...", "code": "179941" }
<span class="comment">// ‚Üí { credential: "PhoneVerified", attestation }</span></code></pre>

    <h3>üêô GitHub OAuth</h3>
    <pre><code>GET /credentials/github/start?did=did:soulprint:abc...
<span class="comment">// ‚Üí redirects to github.com/login/oauth/authorize</span>
GET /credentials/github/callback
<span class="comment">// ‚Üí { credential: "GitHubLinked", github: { login }, attestation }</span></code></pre>
    <p>Config: <code>GITHUB_CLIENT_ID</code>, <code>GITHUB_CLIENT_SECRET</code>, <code>SOULPRINT_BASE_URL</code><br>
    Create OAuth App: <a href="https://github.com/settings/applications/new" target="_blank">github.com/settings/applications/new</a></p>

    <h2>Anti-Farming Engine <span style="font-size:0.7em;background:#e44;color:#fff;padding:2px 8px;border-radius:10px;margin-left:8px">v0.3.0</span></h2>
    <p>Farming attempts are automatically detected and converted to <strong>-1 penalties</strong>.</p>
    <table>
      <tr><th>Rule</th><th>Limit</th></tr>
      <tr><td>Daily gain cap</td><td>Max <strong>+1 point/day</strong> per DID</td></tr>
      <tr><td>Weekly gain cap</td><td>Max <strong>+2 points/week</strong> per DID</td></tr>
      <tr><td>New DID probation</td><td>DIDs &lt; 7 days need 2+ attestations before earning</td></tr>
      <tr><td>Same-issuer cooldown</td><td>Max 1 reward/day per service</td></tr>
      <tr><td>Session duration</td><td>Min <strong>30 seconds</strong></td></tr>
      <tr><td>Tool entropy</td><td>Min <strong>4 distinct tools</strong></td></tr>
      <tr><td>Robotic pattern</td><td>Call interval stddev &lt; 10% of mean ‚Üí penalty</td></tr>
    </table>

    <h2>BFT P2P Consensus <span style="font-size:0.7em;background:#2a9d8f;color:#fff;padding:2px 8px;border-radius:10px;margin-left:8px">v0.3.1</span></h2>
    <p>Soulprint v0.3.1 adds <strong>BFT (Byzantine Fault Tolerant) consensus</strong> for nullifier registration ‚Äî no blockchain, no gas fees, no external dependencies. Everything runs over the existing P2P network.</p>

    <h3>üîÅ PROPOSE ‚Üí VOTE ‚Üí COMMIT</h3>
    <pre><code><span class="comment"># When a new identity is verified:</span>
<span class="comment"># 1. Proposer node broadcasts PROPOSE with ZK proof hash</span>
<span class="comment"># 2. Each node verifies the ZK proof locally</span>
<span class="comment"># 3. Nodes broadcast VOTE (accept/reject)</span>
<span class="comment"># 4. When N/2+1 accepts received ‚Üí COMMIT broadcast to all nodes</span>
<span class="comment"># 5. All nodes store the nullifier as committed</span>

<span class="comment"># Single-node mode (0 peers): immediate local commit ‚Äî no timeout</span></code></pre>

    <h3>Consensus Endpoints</h3>
    <table>
      <tr><th>Endpoint</th><th>Description</th></tr>
      <tr><td><code>GET /consensus/state-info</code></td><td>Handshake for state sync. Returns <code>nullifierCount</code>, <code>protocolHash</code>, <code>nodeVersion</code>. Incompatible nodes rejected immediately.</td></tr>
      <tr><td><code>GET /consensus/state?page=N&amp;since=TS</code></td><td>Bulk state sync (paginated, 500 entries/page). Returns <code>nullifiers[]</code>, <code>attestations{}</code>, <code>reps{}</code>. Incremental with <code>since</code> timestamp.</td></tr>
      <tr><td><code>POST /consensus/message</code></td><td>Receive consensus messages (<code>PROPOSE</code>, <code>VOTE</code>, <code>COMMIT</code>, <code>ATTEST</code>). Payload is AES-256-GCM encrypted. Wrong <code>PROTOCOL_HASH</code> ‚Üí 400.</td></tr>
    </table>

    <h3>Security guarantees</h3>
    <table>
      <tr><th>Property</th><th>Mechanism</th></tr>
      <tr><td>Anti-sybil</td><td>Nullifier = Poseidon(biometrics) ‚Äî one per real person</td></tr>
      <tr><td>Non-repudiation</td><td>Ed25519 signature on every consensus message</td></tr>
      <tr><td>Network isolation</td><td><code>PROTOCOL_HASH</code> verified on every message ‚Äî modified node ignored</td></tr>
      <tr><td>Anti-replay</td><td><code>Set&lt;msgHash&gt;</code> ‚Äî each message applied exactly once</td></tr>
      <tr><td>ZK grounding</td><td>Every voter verifies the ZK proof independently</td></tr>
      <tr><td>Fault tolerance</td><td>Quorum N/2+1 ‚Äî tolerates up to N/2 malicious nodes</td></tr>
    </table>




    <h2>Security Hardening <span style="font-size:0.7em;background:#e63946;color:#fff;padding:2px 8px;border-radius:10px;margin-left:8px">v0.3.5</span></h2>

    <h3>Fix 1 ‚Äî Real Groth16Verifier</h3>
    <p>Production now uses the <strong>real</strong> Groth16 verifier generated by snarkjs from the circuit's proving key. The mock accepted any proof where <code>input[0] != 0</code>. The real verifier performs full elliptic curve pairing checks.</p>
    <table>
      <tr><th></th><th>Mock (old)</th><th>Real (v0.3.5)</th></tr>
      <tr><td>Zero proof</td><td>‚úÖ accepted</td><td>üö´ REVERTS</td></tr>
      <tr><td>Random values</td><td>‚úÖ accepted</td><td>üö´ REVERTS</td></tr>
      <tr><td>Overflow values</td><td>‚úÖ accepted</td><td>üö´ REVERTS</td></tr>
      <tr><td>Valid ZK proof</td><td>‚úÖ accepted</td><td>‚úÖ accepted</td></tr>
    </table>
    <p><strong>Admin locked:</strong> <code>SoulprintRegistry.admin = address(0)</code> ‚Äî only <code>GovernanceModule</code> (70% supermajority) can update the verifier.</p>

    <h3>Fix 2 ‚Äî Code Integrity Hash</h3>
    <pre><code><span class="comment"># Every build computes SHA-256 of all 17 source files</span>
tsc && node scripts/compute-code-hash.mjs
<span class="comment"># ‚Üí dist/code-hash.json: { codeHash, codeHashHex, fileCount }</span>

<span class="comment"># Validator logs at startup:</span>
<span class="comment"># [integrity] ‚úÖ Code hash: 559c4b60... (17 files)</span>

<span class="comment"># Check via API:</span>
curl http://localhost:4888/health
{
  "codeHash":               "559c4b6036fc59ae...",
  "codeHashHex":            "0x559c4b60...",
  "runtimeHash":            "a1b2c3d4...",
  "governanceApprovedHash": "0xdfe1ccca...",
  "nodeCompatible":         true
}</code></pre>

    <h3>Contracts ‚Äî Base Sepolia v0.3.5</h3>
    <table>
      <tr><th>Contract</th><th>Address</th><th>Explorer</th></tr>
      <tr><td><code>Groth16Verifier</code> (real)</td><td><code>0x5b5B...75a6</code></td><td><a href="https://sepolia.basescan.org/address/0x5b5B79a095f2C5c0207414aba9d4d54245EA75a6" target="_blank">BaseScan ‚Üó</a></td></tr>
      <tr><td><code>SoulprintRegistry</code> v2</td><td><code>0xD09e...1f12</code></td><td><a href="https://sepolia.basescan.org/address/0xD09ea421C43fB54b2A079362C7321cB732471f12" target="_blank">BaseScan ‚Üó</a></td></tr>
      <tr><td><code>GovernanceModule</code> v2</td><td><code>0x0d3b...f345</code></td><td><a href="https://sepolia.basescan.org/address/0x0d3bf889D2D353244f748042B48649Fa94AfF345" target="_blank">BaseScan ‚Üó</a></td></tr>
    </table>

    <h3>Test coverage</h3>
    <pre><code>suite.js                   104/104 ‚úÖ
consensus-tests.mjs         32/32  ‚úÖ
blockchain-e2e-tests.mjs    33/33  ‚úÖ
governance-tests.mjs        33/33  ‚úÖ
fix-verification-tests.mjs  43/43  ‚úÖ  ‚Üê Fix 1+2 exhaustivo
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Total:                      245/245 ‚úÖ</code></pre>

    <h2>On-chain Governance <span style="font-size:0.7em;background:#6a4c93;color:#fff;padding:2px 8px;border-radius:10px;margin-left:8px">v0.3.5</span></h2>
    <p>The <strong>GovernanceModule</strong> ensures that no single entity ‚Äî not even the deployer ‚Äî can change the <code>PROTOCOL_HASH</code> without a supermajority of verified validators.</p>

    <h3>How it works</h3>
    <pre><code><span class="comment"># Any upgrade to PROTOCOL_HASH requires:</span>
1. proposeUpgrade(did, newHash, rationale)   ‚Üê verified identity required
2. voteOnProposal(id, did, approve)          ‚Üê 70% supermajority needed
3. 48h timelock                              ‚Üê humans can veto (25% threshold)
4. executeProposal(id)                       ‚Üê anyone can execute after timelock

<span class="comment"># Emergency veto during timelock:</span>
If 25%+ of validators vote AGAINST ‚Üí proposal VETOED immediately</code></pre>

    <h3>Security guarantees</h3>
    <table>
      <tr><th>Guarantee</th><th>Mechanism</th></tr>
      <tr><td>1 identity = 1 vote</td><td>DID must have verified ZK proof in SoulprintRegistry</td></tr>
      <tr><td>No AI takeover</td><td>Biometric identity required per voter ‚Äî can't create infinite voters</td></tr>
      <tr><td>No fast coup</td><td>48h timelock gives humans time to react</td></tr>
      <tr><td>Immutable parameters</td><td>70% / 25% / 48h hardcoded ‚Äî not upgradeable</td></tr>
      <tr><td>Full audit trail</td><td><code>hashHistory[]</code> on-chain ‚Äî every approved hash recorded</td></tr>
    </table>

    <h3>Governance endpoints</h3>
    <pre><code><span class="comment"># Get governance status</span>
curl http://localhost:4888/governance

{
  "currentApprovedHash": "0xdfe1ccca...",
  "blockchainConnected": true,
  "activeProposals": 0,
  "hashHistory": ["0xdfe1ccca..."],
  "nodeCompatible": true
}

<span class="comment"># Propose an upgrade (requires verified identity on-chain)</span>
curl -X POST http://localhost:4888/governance/propose \
  -H "Content-Type: application/json" \
  -d '{"did":"did:key:z6Mk...","newHash":"0xnew...","rationale":"Security patch v1.1"}'

<span class="comment"># Vote on a proposal</span>
curl -X POST http://localhost:4888/governance/vote \
  -d '{"proposalId":0,"did":"did:key:z6Mk...","approve":true}'

<span class="comment"># Execute after timelock (48h)</span>
curl -X POST http://localhost:4888/governance/execute \
  -d '{"proposalId":0}'</code></pre>

    <h3>Contract ‚Äî Base Sepolia</h3>
    <p><a href="https://sepolia.basescan.org/address/0xE74Cd1Aa66541dF76e5a82a05F11f80B31FCe217" target="_blank">0xE74Cd1Aa66541dF76e5a82a05F11f80B31FCe217 ‚Üó</a></p>

    <h2>Blockchain Backup <span style="font-size:0.7em;background:#f4a261;color:#fff;padding:2px 8px;border-radius:10px;margin-left:8px">v0.3.5</span></h2>
    <p>Soulprint v0.3.5 adds <strong>async blockchain backup</strong> ‚Äî P2P is primary, blockchain is permanent record. No downtime if blockchain is unavailable.</p>

    <h3>Architecture</h3>
    <pre><code><span class="comment"># P2P commits instantly (no gas, no wait)</span>
BFT P2P: PROPOSE ‚Üí VOTE ‚Üí COMMIT  (~2s, $0)
    ‚îî‚îÄ‚îÄ‚ñ∂ Response to user  ‚Üê immediate ‚úÖ
    ‚îî‚îÄ‚îÄ‚ñ∂ async (non-blocking)
         BlockchainAnchor ‚Üí Base Sepolia
         ‚îú‚îÄ‚îÄ OK: tx anchored (~5s, free testnet)
         ‚îú‚îÄ‚îÄ fail: retry x3 (0s‚Üí2s‚Üí8s backoff)
         ‚îî‚îÄ‚îÄ 3 fails: blockchain-queue.json</code></pre>

    <h3>Deployed Contracts ‚Äî Base Sepolia</h3>
    <table>
      <tr><th>Contract</th><th>Address</th><th>Explorer</th></tr>
      <tr><td><code>ProtocolConstants</code></td><td><code>0x20EEe...4529</code></td><td><a href="https://sepolia.basescan.org/address/0x20EEeFe3e59e6c76065A3037375053e7A9c94529" target="_blank">BaseScan ‚Üó</a></td></tr>
      <tr><td><code>SoulprintRegistry</code></td><td><code>0xE6F8...54Fd</code></td><td><a href="https://sepolia.basescan.org/address/0xE6F804c3c90143721A938a20478a779F142254Fd" target="_blank">BaseScan ‚Üó</a></td></tr>
      <tr><td><code>AttestationLedger</code></td><td><code>0xD915...fE57</code></td><td><a href="https://sepolia.basescan.org/address/0xD91595bbb8f649e4E3a14cF525cC83D098FEfE57" target="_blank">BaseScan ‚Üó</a></td></tr>
      <tr><td><code>ValidatorRegistry</code></td><td><code>0xE941...eE9</code></td><td><a href="https://sepolia.basescan.org/address/0xE9418dBF769082363e784de006008b1597F5EeE9" target="_blank">BaseScan ‚Üó</a></td></tr>
    </table>

    <h3>Enable blockchain backup</h3>
    <pre><code>SOULPRINT_RPC_URL=https://sepolia.base.org \
SOULPRINT_PRIVATE_KEY=0x... \
SOULPRINT_NETWORK=base-sepolia \
npx soulprint node

<span class="comment"># Node log will show:</span>
<span class="comment"># [anchor] ‚úÖ Blockchain backup enabled ‚Äî Base Sepolia</span>
<span class="comment"># [anchor] ‚úÖ nullifier 0xaa... ‚Üí blockchain tx 0x1234...</span></code></pre>

    <h3>GET /anchor/stats</h3>
    <pre><code>curl http://localhost:4888/anchor/stats

{
  "nullifiersAnchored":  12,
  "attestsAnchored":     47,
  "pendingNullifiers":   0,
  "pendingAttests":      0,
  "blockchainConnected": true,
  "lastAnchorTs":        1740000000000
}</code></pre>

    <h2>Configuration</h2>
    <h3>Environment Variables</h3>
    <table>
      <tr><th>Variable</th><th>Default</th><th>Description</th></tr>
      <tr><td><code>SOULPRINT_HTTP_PORT</code></td><td><code>4888</code></td><td>HTTP API port</td></tr>
      <tr><td><code>SOULPRINT_P2P_PORT</code></td><td><code>6888</code></td><td>P2P libp2p port (HTTP port + 2000)</td></tr>
      <tr><td><code>SOULPRINT_HOST</code></td><td><code>0.0.0.0</code></td><td>Bind address for HTTP API</td></tr>
      <tr><td><code>SOULPRINT_BOOTSTRAP</code></td><td>none</td><td>Comma-separated bootstrap multiaddrs (for joining mainnet)</td></tr>
      <tr><td><code>SOULPRINT_DATA_DIR</code></td><td><code>~/.soulprint</code></td><td>Directory for persistent data (keys, attestations, proof registry)</td></tr>
      <tr><td><code>SOULPRINT_RATE_LIMIT</code></td><td><code>100</code></td><td>Max requests per minute per IP</td></tr>
      <tr><td><code>SOULPRINT_OPERATOR_KEY</code></td><td>auto-generated</td><td>Operator private key (persisted to <code>$DATA_DIR/operator.key</code>)</td></tr>
    </table>

    <h3>Example ‚Äî Custom ports</h3>
    <pre><code>SOULPRINT_HTTP_PORT=8000 SOULPRINT_P2P_PORT=10000 npx soulprint node</code></pre>

    <h3>Example ‚Äî Connect to mainnet bootstrap node</h3>
    <pre><code>SOULPRINT_BOOTSTRAP=<span class="string">"/ip4/&lt;bootstrap-ip&gt;/tcp/6888/p2p/&lt;bootstrap-peer-id&gt;"</span> \
  npx soulprint node</code></pre>

    <h2>P2P Network Architecture</h2>
    <p>The Soulprint P2P network uses <strong>libp2p v2.10</strong> with the following stack:</p>
    <table>
      <tr><th>Component</th><th>Purpose</th></tr>
      <tr><td>TCP Transport</td><td>Reliable connection layer</td></tr>
      <tr><td>Noise encryption</td><td>Encrypted channels between all peers</td></tr>
      <tr><td>Yamux multiplexing</td><td>Multiple streams per connection</td></tr>
      <tr><td>Kademlia DHT</td><td>Peer routing and discovery</td></tr>
      <tr><td>GossipSub</td><td>Attestation broadcast (topic: <code>soulprint-attestations-v1</code>)</td></tr>
      <tr><td>mDNS</td><td>Auto-discovery on local networks</td></tr>
    </table>

    <h3>Dual-channel attestation propagation</h3>
    <p>When a validator issues an attestation, it is sent via two channels simultaneously:</p>
    <ul>
      <li><strong>Primary:</strong> GossipSub broadcast to all peers on <code>soulprint-attestations-v1</code></li>
      <li><strong>Fallback:</strong> HTTP <code>POST /reputation/attest</code> to known peer HTTP endpoints (for legacy nodes)</li>
    </ul>
    <p>Anti-loop and anti-replay protections prevent attestations from cycling: each message has a unique ID; nodes that have already processed an ID discard duplicates.</p>

    <h2>Validator Data Persistence</h2>
    <p>The node persists the following to <code>$SOULPRINT_DATA_DIR</code>:</p>
    <ul>
      <li><code>operator.key</code> ‚Äî the node's signing key (auto-generated on first run)</li>
      <li><code>proof-hashes.db</code> ‚Äî registry of seen identity proof hashes (anti-replay)</li>
      <li><code>reputation.db</code> ‚Äî reputation scores per DID</li>
      <li><code>attestations.log</code> ‚Äî audit log of all issued attestations</li>
    </ul>

    <h2>Security Considerations</h2>
    <div class="callout callout-warn">
      <div class="callout-title">Rate limiting</div>
      The default rate limit is 100 requests/min per IP. Set <code>SOULPRINT_RATE_LIMIT</code> lower for public-facing nodes. DDoS protection via IP banning is implemented after 10x rate limit breach.
    </div>
    <div class="callout callout-warn">
      <div class="callout-title">Anti-Sybil protection</div>
      Each identity hash can only be registered once. A validator that tries to register duplicate hashes will have its attestations rejected by the network.
    </div>

    <h2>Docker Deployment</h2>
    <pre><code>docker run -d \
  --name soulprint-node \
  -p 4888:4888 \
  -p 6888:6888 \
  -v ~/.soulprint:/data \
  -e SOULPRINT_DATA_DIR=/data \
  -e SOULPRINT_BOOTSTRAP=<span class="string">"&lt;bootstrap-multiaddr&gt;"</span> \
  node:20-alpine \
  sh -c <span class="string">"npm i -g soulprint && soulprint node"</span></code></pre>

    <h2>Monitoring</h2>
    <pre><code><span class="comment"># Node health check</span>
curl http://localhost:4888/info

<span class="comment"># Response:</span>
{
  <span class="string">"peerId"</span>:             <span class="string">"12D3KooW..."</span>,
  <span class="string">"version"</span>:            <span class="string">"0.2.2"</span>,
  <span class="string">"httpPort"</span>:           <span class="keyword">4888</span>,
  <span class="string">"p2pPort"</span>:            <span class="keyword">6888</span>,
  <span class="string">"connectedPeers"</span>:     <span class="keyword">3</span>,
  <span class="string">"attestationsIssued"</span>: <span class="keyword">142</span>,
  <span class="string">"proofHashesStored"</span>:  <span class="keyword">891</span>,
  <span class="string">"uptime"</span>:             <span class="keyword">86400</span>
}</code></pre>
  
    <h2>Challenge-Response Peer Integrity <span style="font-size:0.7em;background:#e63946;color:#fff;padding:2px 8px;border-radius:10px;margin-left:8px">v0.3.7</span></h2>
    <p>Soulprint v0.3.7 adds <strong>cryptographic peer verification</strong> ‚Äî before accepting a new peer, the node challenges it to prove it's running unmodified ZK verification code.</p>

    <h3>How it works</h3>
    <p>The challenger sends two ZK proofs: one <strong>known-valid</strong> (the protocol's official test vector) and one <strong>freshly-mutated invalid proof</strong> (unique per challenge via random nonce). The peer must correctly return <code>true</code> for the valid proof and <code>false</code> for the invalid one ‚Äî and sign the response with its node key.</p>

    <table>
      <tr><th>Attack</th><th>Detection</th></tr>
      <tr><td>ZK always returns <code>true</code> (bypass)</td><td>Invalid proof test fails</td></tr>
      <tr><td>ZK always returns <code>false</code></td><td>Valid proof test fails</td></tr>
      <tr><td>Pre-computed / cached response</td><td>Random nonce makes each challenge unique</td></tr>
      <tr><td>Node impersonation</td><td>Ed25519 signature tied to <code>node_did</code></td></tr>
      <tr><td>Replay attack</td><td>30-second challenge TTL</td></tr>
    </table>

    <h3>Endpoint</h3>
    <pre><code>POST /challenge
Body: {
  challenge_id: string,    // UUID nonce
  nonce: string,           // 32-byte hex ‚Äî makes invalid_proof unique
  issued_at: number,       // unix timestamp (TTL: 30s)
  valid_proof: ZKProof,    // protocol's official test vector
  invalid_proof: ZKProof   // mutated proof ‚Äî must fail verification
}

Response 200:
{
  challenge_id: string,
  result_valid: true,      // valid proof verified correctly
  result_invalid: false,   // invalid proof rejected correctly
  verified_at: number,
  node_did: string,
  signature: string        // Ed25519(challenge_id + results + verified_at, node_key)
}</code></pre>

    <h3>Automatic peer verification</h3>
    <p><code>POST /peers/register</code> now automatically runs <code>verifyPeerBehavior()</code> before accepting any peer. A peer with modified ZK code is rejected with <strong>HTTP 403</strong>.</p>

    <h2>SPT Auto-Renewal <span style="font-size:0.7em;background:#4ade80;color:#000;padding:2px 8px;border-radius:10px;margin-left:8px">v0.3.6</span></h2>
    <p>Tokens now renew automatically ‚Äî no more downtime when a 24-hour SPT expires.</p>
    <table>
      <tr><th>Scenario</th><th>Window</th><th>Action</th></tr>
      <tr><td>Token valid, &lt; 1h remaining</td><td>Pre-emptive</td><td>Auto-renew</td></tr>
      <tr><td>Token expired &lt; 7 days ago</td><td>Grace period</td><td>Auto-renew</td></tr>
      <tr><td>Token expired &gt; 7 days ago</td><td>Stale</td><td>Full re-verification required</td></tr>
    </table>
    <pre><code>POST /token/renew
Body: { "spt": "&lt;current_token&gt;" }

Response 200:
{
  "spt": "&lt;new_token&gt;",
  "expires_in": 86400,
  "renewed": true,
  "method": "preemptive" | "grace_window"
}</code></pre>

</main>
</div>
</body>
</html>
